# LeetCode刷题笔记

## 树、二叉树

### [95. Unique Binary Search Trees II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) 

`二叉搜索树、后续遍历` 

#### 1. 问题描述

> Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.

**Example：**

<img src="Figure/LeetcodeNote/95_1.jpeg" style="zoom:80%;" />

```
Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

#### 2. 问题分析

​	拿到这道题，首先有一个朴素的但是不太好操作的想法：自上而下生成二叉搜素树，也就是前序遍历生成。在生成过程中，先确定根节点(循环遍历根结点的每一种可能性)，然后确定左右子树。但是，这样做会产生两个问题：1. 如何判断以i为根结点的所有二叉搜索树均已生成 2. 如何返回(或者说保存)已经生成的二叉搜索树。也就是说，当我们自上而下生成一棵树之后，我们不仅需要将这棵树加到List列表中，同时还要返回前一个节点去探索其他可能性，如何处理这两个问题在前序遍历的方法下会比较麻烦。我对照下面的图来做具体的解释。

<img src="Figure/LeetcodeNote/95_2.jpeg" style="zoom:30%;" />

​	当我们用递归的方式前序遍历生成树时，会先确定根结点，再确定左子树的根结点，再确定左子树的左子树的根结点，依次类推。但是在这个过程中，根结点虽然被确定了，但是左子树与根结点的连接并没有建立，只有当递归函数返回时才会建立二者之间的连接。所以说，对于这道题，如果采用前序遍历的方法，只有当递归完全返回之后，一棵树才得以建立起来。但是，如果完全返回，我们生成这棵树的中间结果就会被抛弃，在接下来生成具有相同根的另一棵树时就不知道这棵树是否被生成，这样就会产生问题。也许如果采用前序遍历的。(迭代也是如此)

​	而如果考虑自底向上生成所有二叉搜索树，即后序遍历的方法，情况就会有所不同。我们可以先求出以i为根结点的左子树的所有情况，以及右子树的所有情况，然后将左子树的可能情况添加到根结点的左孩子上，右子树的可能情况添加到根结点的右孩子上。这样自底向上地生成，就会比较方便的解决上面提到的两个问题。

#### 3. 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n == 0) {
            return null;
        }
        return generateTrees(1, n);
    }
    
    public List<TreeNode> generateTrees(int low, int high) {
        List<TreeNode> allTrees = new LinkedList<TreeNode>();
        if(low > high) {
            allTrees.add(null);
            return allTrees;
        }
        for(int i = low; i <= high; i ++) {
            // 后序遍历，对左右子树的操作
            List<TreeNode> leftchild = generateTrees(low, i - 1); // 生成某一节点左子树的所有情况，存储在List内
            List<TreeNode> rightchild = generateTrees(i + 1, high); // 生成某一节点右子树的所有情况，存储在List内
            
            // 对根结点的操作：根据leftchild和rightchild，双重循环，生成所有以i为根结点的可能的子树。
            for(TreeNode left: leftchild) {
                for(TreeNode right: rightchild) {
                    TreeNode root = new TreeNode(i);
                    root.left = leftchild;
                    root.right = rightchild;
                    allTrees.add(root);
                }
            }
        }
        return allTrees;
    }
}
```

