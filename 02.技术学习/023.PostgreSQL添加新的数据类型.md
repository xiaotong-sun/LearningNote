## src/turotial/makefile解析

```makefile
%.sql: %.source
	rm -f $@; \
	C=`pwd`; \
	sed -e "s:_OBJWD_:$$C:g" < $< > $@
```

这段代码是一个makefile规则，它描述了如何根据每个 `.source` 文件生成对应的 `.sql` 文件。 

1. `%.sql: %.source ` 这一行是规则的头部，它指定了生成的目标文件以及所依赖的源文件格式。这里的 `%` 是一个通配符，表示任意的文件名（不包括目录部分），因此 `%.sql` 匹配所有的 `.sql` 文件，而 `%.source` 匹配相同文件名的 `.source` 文件。 
2. `rm -f $@; \ ` 这行使用 `rm -f` 命令来删除当前目标文件（`$@` 表示目标文件名），`; \` 是换行符的转义，表示命令在多行中。 
3. ```C=`pwd`; \ ``` 这行用于获取当前工作目录，并将其赋值给变量 `C`。这个命令使用反引号 `` ` `` 来执行一个 shell 命令，并将其结果赋值给变量 `C`。
4. ```sed -e "s:_OBJWD_:$$C:g" < $< > $@ ``` 最后这行则使用了 `sed` 命令，它从源文件(`< $<`)中读取内容，并将替换后的内容写入目标文件(`> $@`)。具体来说，它是在读取源文件中的内容时，将 `_OBJWD_` 替换为当前工作目录的绝对路径。

因此，整个规则的功能是：根据每个 `.source` 文件生成对应的 `.sql` 文件，其中将源文件中的 `_OBJWD_` 替换为当前工作目录的绝对路径。这样的操作可能是为了在生成 SQL 文件时，插入当前的工作目录信息。 



## 38.10 C-Language Functions

用户定义的函数可以用C（或与C兼容的语言，例如C++）编写。这些函数被编译成动态可加载对象（也称为共享库）并由服务器按需加载。

动态加载功能是“C语言”函数与“内部”函数的区别——两者的实际编码约定本质上是相同的。（因此，标准内部函数库是用户定义的C函数编码示例的丰富来源。）

目前，C函数仅使用一种调用约定（版本1）。通过为函数编写PG_FUNCTION_INFO_V1() 宏调用来指示对该调用约定的支持。



### 38.10.2 Base Types in C-Language Functions

基础类型有三种传递方式，如下所示

- **值传递**，仅用于固定长度，并且长度只能为1、2、4或者8字节。
- **引用传递**，可用于固定长度，当长度大于8字节时，只能通过引用传递来进行。
- **引用传递**，对于所有的可变长度的数据类型，只能通过引用传递来进行。



### 38.10.3 Version 1 Calling Conventions

这部分给出了一个实例，并且解释了V1调用规范的必要性。



### 38.10.4 Writing Code

这部分介绍了在写C-language functions时的一些规范和注意事项。

大体包括以下几点：

- 要定义一个“magic block”，使其能够在动态加载的时候检测明显的不兼容问题。
- 使用`palloc`和`pfree`来代替C语言中的`malloc`和`free`，使用`palloc`分配的空间会自动地释放。
- 要使用`memset`或者`palloc0`将一个数据结构的每一个字节都初始化为0
- 编写function时，通常需要包含`postgres.h`和`fmgr.h`这两个头文件。其中`postgres.h`包含了internal PostgreSQL types，`fmgr.h`包含了一些函数管理接口（例如：`PG_FUNCTION_ARGS`）.
- 注意变量名不要与内置的一些关键字或函数名冲突。



















