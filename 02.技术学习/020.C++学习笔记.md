# C++基础入门

## 1.基本语法

### 1.1 基本结构

```c++
#include <iostream>
using namespace std;

int main() {
    cout << "hello world" << endl;
    return 0;
}
```



### 1.2 注释

```c++
// 1. 单行注释

/*
   2. 多行注释
   2. 多行注释
*/
```



### 1.3 变量

**作用：** 给一段指定的内存空间起名，从而方便操作这段内存空间

**语法：** `数据类型 变量名 = 变量初始值;`

**示例：** `int a = 10;`



**变量命名规则：**

- 标识符不能是关键字
- 标识符只能由数字、字母、下划线组成
- 标识符只能由字母、下划线开头
- 标识符区分大小写



### 1.4 常量

**作用：** 用于记录程序中不可更改的数据

**语法：** `#define 常量名 常量值` 或 `const 数据类型 常量名 = 常量值`

**示例：** `#defint day 7` 或 `const int day = 7`



### 1.5 数据类型

#### 整型

| 数据类型  |                     占用空间                     |              取值范围              |
| :-------: | :----------------------------------------------: | :--------------------------------: |
|   short   |                      2Byte                       | -2<sup>15</sup> ~ 2<sup>15</sup>-1 |
|    int    |                      4Byte                       | -2<sup>31</sup> ~ 2<sup>31</sup>-1 |
|   long    | Windows为4Byte， Linux为4Byte(32位)，8Byte(64位) | -2<sup>31</sup> ~ 2<sup>31</sup>-1 |
| long long |                      8Byte                       | -2<sup>63</sup> ~ 2<sup>63</sup>-1 |



#### 实型（浮点型）

| 数据类型 | 占用空间 | 取值范围        |
| -------- | -------- | --------------- |
| float    | 4Byte    | 7位有效数字     |
| double   | 8Byte    | 15~16位有效数字 |

浮点数可以使用科学计数法表示，例如:`3.2e-3`



#### 字符型

**语法：** `char ch = 'a';`

- C和C++中字符类型的变量只占用一个字节
- 字符型变量存储的并非是该字符，而是该字符的ASCII编码



#### 字符串类型

**语法：** `string 变量名 = "字符串值"` 或 `char str[] = "字符串值"`

【注意】：C++风格字符串(前一种)，需要加入头文件`#include<string>`， string类型占用32个字节，字符数组的形式由字符串长度决定内存大小



#### 布尔类型

- true，本质为1
- false，本质为0
- 占用1个字节

`bool flag = true`, `bool flag = false`



#### sizeof关键字

**作用：** 统计数据类型所占用的内存空间大小，单位为==字节==

**语法：** `sizeof(数据类型\变量)`

**示例：** `sizeof(int)`, `sizeof(name)`



### 1.6 输入和输出

**数据输入：** `cin >> 变量;`

**数据输出：** `cout << 数据 << endl;`



### 1.7 数组

#### 一维数组

- `数据类型 数组名[数组长度];`
- `数据类型 数组名[数组长度] = {1,2,3,4,....};`
- `数据类型 数组名[] = {1,2,3,4};`



#### 二位数组

- `数据类型 数组名[行数][列数];`
- `数据类型 数组名[2][3] = {{1,2,3}, {4,5,6}};`
- `数据类型 数组名[2][3] = {1,2,3,4,5,6};`
- `数据类型 数组名[][3] = {1,2,3,4,5,6};`



## 2.程序流程结构

### 2.1 goto语句

**作用：** 无条件跳转语句

**语法：** `goto 标记；`

**解释：** 如果标记名称存在，则跳转到该标记位置继续执行

**示例:**

```C++
int main() {
    cout << "1" << endl;
    
    goto FLAG;
    
    cout << "2" << endl;
    cout << "3" << endl;
    
    FLAG:
    
    cout << "4" << endl;
    cout << "5" << endl;
    
    return 0;
}
```



### 2.2 switch语句

**作用：** 基于条件选择执行的操作

**语法：** `switch (条件){case 条件1：break;default: break;}`

**示例：**

```c++
int flag;
switch (flag) {
    case 1:
        pass;
        break;
    case 2:
        pass;
        break;
    case 3:
        pass;
        break;
    default:
        pass;
        break;
}
```



==注意：==如果在case语句里面，需要声明变量，或者要执行的操作比较多，需要将这些部分用`{}`括起来,例如：

```c++
case 1:
{
    int a = 0;
    pass;
}
	break;
```





## 3.函数

### 3.1 函数的定义

函数的定义一般分为五个步骤：

1. 返回值类型
2. 函数名
3. 参数列表
4. 函数体
5. return表达式

**语法：**

```c++
返回值类型 函数名(参数列表) {
    
    函数体;
    
    return 表达式；
}
```



### 3.2 函数的声明

**语法：** `返回值类型 函数名(参数列表);`

函数的声明可以有多次，但函数的定义只能有一次。

如果函数在main()函数后面被定义，那么必须在main()函数前面进行函数的声明。



### 3.3 函数的分文件编写

**作用：** 让代码结构更加清晰

**步骤：**

1. 创建后缀名为`.h`的头文件
2. 创建后缀名为`.cpp`的源文件
3. 在`.h`文件中写函数的声明
4. 在`.cpp`文件中写函数的定义

```c++
// swap.h文件
#include <iostream>
using namespace std;

void swap(int a, int b); // 放置函数声明

---------------------------------------
// swap.cpp文件
#include "swap.h"

void swap(int a, int b) { // 放置函数定义
    int temp = a;
    a = b;
    b = temp;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
}
```



## 4.指针

### 4.1 指针的概念

**指针的作用：** 可以通过指针间接的访问内存



### 4.2 指针的定义及使用

**语法：** `数据类型* 指针变量名;`

**例子：** `int* p;`

可以通过取地址符来对指针进行赋值，例如：`int* p = &a;`

为了避免出现==野指针==的情况，通常在声明指针的时候赋值为NULL,从而将指针指向内存空间编号为0的空间:`int* p = NULL;`。注意，内存空间编号为0~255为系统占用内存，不允许用户访问。



> 野指针：指针变量指向非法的内存空间
>
> 示例：
>
> ```c++
> int mai() {
>     // 指针变量p指向内存地址编号为0x1100的空间
>     int *p = (int *) 0x1100;
>     
>     // 访问野指针报错
>     cout << *p << endl;
>     return 0;
> }
> ```
>
> 总结：空指针和野指针都不是我们申请的内存空间，因此不要访问。



### 4.3 指针所占的内存空间大小

指针存放的是16进制的地址，在32位系统中，指针所占用的内存大小为4Byte，不管是什么数据类型；在64位系统中为8Byte。



### 4.4 const修饰指针⭐

**const修饰指针的三种情况**

- const修饰指针 --> 常量指针（指向常量的指针）
    - `const int* p = &a;`
    - 指针的指向可以修改，但是指针指向的值不可以修改
- const修饰常量 --> 指针常量（指针类型的常量）
    - `int* const p = &a;`
    - 指针的指向不可以修改，但是指针指向的值可以修改
- const既修饰指针又修饰常量
    - `const int* const p = &a;`
    - 指针的指向和指向的值均不可以修改

```c++
#include <iostream>

using namespace std;

int main() {
    int a = 10;
    int b = 20;

    // 常量指针
    const int* p1 = &a;
    p1 = &b; // 正确
    *p1 = 30; // 错误

    // 指针常量
    int* const p2 = &a;
    *p2 = 30; // 正确
    p2 = &b; // 错误
	
    // const既修饰常量又修饰指针
    const int* const p3 = &a;
    p3 = &b; // 错误
    *p3 = 40; // 错误
}
```



### 4.5 指针和数组

**作用：** 利用指针访问数组元素

```c++
#include <iostream>

using namespace std;

int main() {
    int arr[10] = {1,2,3,4,5,6,7,8,9,10};

    int* p = arr;

    // 利用指针遍历数组
    for (int i = 0; i < 10; ++i) {
        cout << *(p ++) << endl;
    }

    return 0;
}
```



### 4.6 指针和函数

**作用：** 利用指针作为函数参数，可以修改实参的值。

```c++
#include <iostream>

using namespace std;

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int a = 10;
    int b = 20;

    swap(&a, &b);

    cout << "a:" <<  a << "\nb:" << b << endl;

    return 0;
}
```



### 4.7 指针、数组、函数

**案例描述：** 封装一个函数，利用==冒泡排序==，实现对整数数组的升序排序。

```c++
#include <iostream>

using namespace std;

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void bubbleSort(int* arr, int len) {
    for (int i = 0; i < len - 1; i ++) {
        for (int j = 0; j < len - i - 1; j ++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main() {
    int arr[10] = {4,3,6,9,1,2,10,8,7,5};
    int len = sizeof(arr) / sizeof(int);

    bubbleSort(arr, len);

    for (int i = 0; i < len; ++i) {
        cout << arr[i] << endl;
    }
}
```



## 5.结构体

### 5.1 结构体基本概念

结构体属于用户自定义的数据结构，允许用户存储不同的数据类型。



### 5.2 结构体的定义和使用

**语法：** `struct 结构体名 {结构体成员列表};` (struct不可省略)

通过结构体创建变量的方式有三种：

- `struct 结构体名 变量名;` （struct可以省略）
- `struct 结构体名 变量名 = {值1，值2...};` （struct可以省略）
- 定义结构体时顺便创建变量。



```c++
struct Student {
    string name;
    int age;
    int score;
};

int main() {
    // 第一种方式
    struct Student s1; 
    /* 或者 Student s1; */
    s1.name = "Amy";
    s1.age = 20;
    s1.score = 100;
    
    // 第二种方式
    struct Student s2 = {"Jam", 19, 99};
    
    // 第三种方式
    /*
    	struct Student {
    		string name;
    		int age;
    		int score;
    	} s3;
    */
}
```



### 5.3 结构体数组

**作用：** 将自定义结构体放到数组中方便维护

**定义：** `struct 结构体名 数组名[元素个数] = {{},{},{},...};`

```c++
#include <iostream>

using namespace std;

struct Student {
    string name;
    int age = 0;
    int score = 0;
};

int main() {
    Student stu[3] = {
            {"amy", 20, 100},
            {"jam", 20, 99},
            {"jack", 19, 89}
    };
    stu[1].name = "tom";

    for(Student s : stu) {
        cout << s.name << "--" << s.age << "--" << s.score << endl;
    }
}
```



### 5.4 结构体指针

**作用：** 通过指针访问结构体中的成员

- 利用操作符`->`可以通过结构体指针访问结构体属性

```c++
#include <iostream>

using namespace std;

struct Student {
    string name;
    int age = 0;
    int score = 0;
};

int main() {
    Student s1 = {"tom", 20, 200};
    Student *p = &s1;
    cout << p->name << "--" << p->age << "--" << p->score << endl;
}
```



### 5.5 结构体嵌套结构体

**作用:** 结构体中的成员可以是另一个结构体

**示例：**

```c++
struct Student {
    string name;
    int age = 0;
    int score = 0;
};

struct Teacher {
    int id = 0;
    string name;
    int age = 0;
    struct Student stu[20]; 
};
```



### 5.6 结构体作函数参数

**作用：** 将结构体作为参数向函数中传递

传递方式有两种：

- 值传递
- 地址传递

**示例：**

```c++
#include <iostream>

using namespace std;

struct Student {
    string name;
    int age = 0;
    int score = 0;
};

// 值传递
void printStudent(struct Student s) {
    s.age = 100;
    cout << s.name << "--" << s.age << "--" << s.score << endl;
}

// 地址传递
void printStudent2(struct Student *s) {
    s->age = 100;
    cout << s->name << "--" << s->age << "--" << s->score << endl;
}

int main() {
    struct Student s;
    s.name = "sam";
    s.age = 10;
    s.score = 90;

    printStudent(s);
    cout << s.name << "--" << s.age << "--" << s.score << endl;
    printStudent2(&s);
    cout << s.name << "--" << s.age << "--" << s.score << endl;
}
```

> 如果不想修改主函数中的数据，用值传递，反之用地址传递。



### 5.7 结构体中const使用场景

**作用：** 用const防止误操作

**示例：**

```c++
#include <iostream>

using namespace std;

struct Student {
    string name;
    int age = 0;
    int score = 0;
};

// 将函数中的形参改为指针，可以减少内存空间，而且不会复制新的副本出来
// 但此时为了避免误修改，需要加const修饰；
void printStudent(const struct Student *s) {
    cout << s->name << "--" << s->age << "--" << s->score << endl;
}

int main() {
    struct Student s;
    s.name = "sam";
    s.age = 10;
    s.score = 90;

    printStudent(&s);
    cout << s.name << "--" << s.age << "--" << s.score << endl;
}
```



### 5.8【案例1】

<center><img src="./../99.Figure/02-020/image-20230817224250817.png" alt="image-20230817224250817" style="zoom:80%;" /></center>

```c++
#include <iostream>
#include <string>
#include <ctime>

using namespace std;

struct Student {
    string sName;
    int score = 0;
};

struct Teacher {
    string tName;
    Student sArray[5];
};

void allocateSpace(struct Teacher tArray[], int len) {
    string nameSeed = "ABCDE";
    for (int i = 0; i < len; ++i) {
        tArray[i].tName = "Teacher_";
        tArray[i].tName += nameSeed[i];

        for (int j = 0; j < 5; ++j) {
            tArray[i].sArray[j].sName = "Student_";
            tArray[i].sArray[j].sName += nameSeed[j];

            int random = rand() % 61 + 40; // 生成[40,100]之间的随机数
            tArray[i].sArray[j].score = random;
        }
    }
}

void printInfo(Teacher tArray[], int len) {
    for (int i = 0; i < len; ++i) {
        cout << "老师的姓名：" << tArray[i].tName << endl;

        for (int j = 0; j < 5; ++j) {
            cout << "\t" << "学生的姓名：" << tArray[i].sArray[j].sName << "\t" << tArray[i].sArray[j].score << endl;
        }
        cout << "\n" << endl;
    }
}

int main() {
    // 设置随机数种子
    srand((unsigned int)time(NULL));
    
    struct Teacher tArray[3];
    int len = sizeof(tArray) / sizeof(tArray[0]);
    allocateSpace(tArray, len);
    printInfo(tArray, len);
}
```



# C++核心编程

## 1. 内存分区模型

C++程序在执行时，将内存大方向划分为==四个区域==

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放全局变量，静态变量，常量等
- 栈区：由编译器自动分配，存放函数的参数值和局部变量等。
- 堆区：由程序员分配释放，若程序员未释放，则由操作系统在程序结束时收回

**内存四区的意义：**

不同区域存放不同的数据，有不同的生命周期，给我们更大的灵活编程。



### 1.1 程序运行前

在程序编译后，生成了exe可执行文件，未执行该程序前，分为两个区域

**代码区：**

- 存放cpu执行的机器指令
- 代码区是==共享==的，一个程序的多次运行共享一个代码区
- 代码区是只读的，不可以被修改



**全局区：**

- 存放全局变量和静态变量、
- 全局区还包含了常量区、字符串常量和其他常量
- 该区域的数据在程序结束后由操作系统释放



**注意：** 

- 局部变量、==局部常量==不在全局区中
- 静态变量，全局变量，全局常量在全局区中



### 1.2 程序运行后

**栈区：**

- 由编译器自动分配释放，存放函数的参数值、局部变量等。
- 注意，不要返回局部变量的地址值，栈区开辟的数据由操作系统自动释放。



**堆区：**

- 由程序员分配释放，若程序员未释放，则由操作系统在程序结束时收回。
- C++主要利用`new`在堆区中开辟内存。

```c++
int* func() {
    int* p = new int(10);
    return p;
}

int main() {
    int* p = func();
    cout << *p << endl;
}
```



### 1.3 new操作符

C++中利用new操作符在堆区开辟数据

堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符`delete`

**语法**：`new 数据类型`

利用new创建的数据，会返回该值数据类型对应的指针。

```c++
// 在堆区创建数组
void test02() {
    int* p = new int[10];

    for (int i = 0; i < 10; i++)
    {
        p[i] = i + 100;
    }

    for (int i = 0; i < 10; i++)
    {
        cout << p[i] << endl;
    }

    delete[] p; // 释放数组时，需要使用delete[]
}
```



## 2. 引用

### 2.1 引用的基本使用

**作用：**给变量起别名

**语法：**`数据类型 &别名 = 原名；`

```c++
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int& b = a;
    cout << a << endl;
    cout << b << endl;
    b = 100;
    cout << a << endl;
    cout << b << endl;
}
```



### 2.2 引用的注意事项

1. 引用必须要初始化
2. 引用一旦初始化后，就不可以更改



### 2.3 引用做函数参数

**作用：**函数传参时，可以利用引用的技术让形参修饰实参

**优点：**可以简化指针修改实参

```c++
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int a = 10;
    int b = 20;
    swap(a, b);
    cout << a << endl;
    cout << b << endl;
}
```

总结：通过引用参数产生的效果同地址传递是一样的，引用语法更为清楚。



### 2.4 引用做函数返回值

**作用：**引用是可以作为函数的返回值存在的



**注意：**不要返回局部变量的引用。

**用法：**函数的调用可以作为左值。

```c++
int& test() {
    static int a = 10;
    return a;
}

int main() {
    int& ref = test();
    cout << ref << endl;

    ref = 100;
    cout << ref << endl;

    test() = 1000;
    cout << ref << endl;
}
```



### 2.5 引用的本质

**本质：**指针常量

```c++
int main() {
    int a = 10;
    
    // 自动转化为 int* const ref = &a;指针常量的指向不可更改，这也说明为什么引用不可更改
    int& ref = a;
    ref = 20； // 内部发现ref是引用，自动帮我们转化成*ref = 20；
}
```

C++推荐使用引用技术，引用的本质是指针常量，但是所有的指针操作编译器都帮我们做了。



### 2.6 常量引用

**作用：**用于修饰形参，防止误操作

在函数形参列表中，可以加`const`修饰形参，防止形参改变实参

常量引用`const int& reg = a;`相当于`const int* const reg = &a;`

```c++
void showValue(const int& v) {
    cout << v << endl;
}

int main() {
    // int& ref = 10; 引用本身需要一个合法的内存空间，因此这一行是错误的
    // 加入const就可以了，编译器会自动优化成：int temp=10; const int& reg = temp;
    const int& ref = 10; // 所以说这里的ref并非指向常量区的10，而是指向一个我们看不见的temp=10
    cout << ref << endl;
    
    int a = 10;
    showValue(a); // 函数中利用常量引用防止误操作，修改实参。
}
```



## 3. 函数提高

### 3.1 函数默认参数

在c++中，函数的形参列表中的形参是可以有默认值的。

**注意事项:**

- 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认参数
- 如果函数声明有默认参数，函数实现就不能有默认参数,反之亦然。（声明和实现只能有一个默认参数）



**语法：** `返回值类型 函数名 (参数=默认值) {}`

```c++
int func(int a = 10, int b = 10, int c = 10) {
    int temp = a + b + c;
    return temp;
}

// 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认参数
int func2(int a, int b, int c = 1, int d = 2) {
    pass;
}

// 如果函数声明有默认参数，函数实现就不能有默认参数
int func3(int a = 10, int b = 10);

int func3(int a, int b) {
    return a + b;
}

int main() {
    int a = 1;
    int b = 2;
    int ans = func(a, b);
    cout << ans << endl;
}
```



### 3.2 函数占位参数

C++中函数的形参列表里可以有占位参数，用来占位，调用函数是必须填补该位置

**语法：** `返回值类型 函数名(数据类型) {}`

```c++
// 后面那个int就是占位参数
// 占位参数还可以有默认参数
void func(int a, int = 10) {
    cout << "func" << endl;
}

int main() {
    // 在使用时，占位参数必须被填补，如果有默认就可以不传
    func(10, 10);
}
```



### 3.3 函数重载

#### 3.3.1 函数重载概述

**作用：**函数名可以相同，提高复用性

**需要满足的条件：**

- 同一个作用域下
- 函数名相同
- 函数参数的类型不同、数量不同、顺序不同

**注意:** 函数的返回值不可以作为函数重载的条件。

```c++
int func(int a, int b) {
    cout << "func_ab" << endl;
    return a + b;
}

int func(int a, int b, int c) {
    cout << "func_abc" << endl;
    return a + b + c;
}

int main() {
    int a = 1;
    int b = 2;
    int c = 2;
    cout << func(a, b) << endl;
    cout << func(a, b, c) << endl;
}
```



#### 3.3.2 函数重载注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

```c++
// 1.引用作为函数重载
void fun(int& a) {
    cout << "fun(int& a)的调用" << endl;
}

void fun(const int& a) {
    cout << "fun(const int& a)的调用" << endl;
}

// 2.函数重载碰到默认参数
void fun2(int a) {
    cout << "fun2(int a)的调用" << endl;
}

void fun2(int a, int b = 10) {
    cout << "fun2(int a, int b = 10)的调用" << endl;
}

int main() {
    // 使用fun(int& a)来运行
    int a = 10;
    int& ref = a;
    fun(ref);

    // 使用fun(const int& a)来运行
    fun(10);

    // 当函数重载碰到默认参数，会出现二义性，报错，因此在函数重载时尽可能不使用默认参数
    fun2(a); // ！！！报错
}
```



## 4 类和对象

c++面向对象的三大特性为：==封装、继承、多态==

c++认为万事万物皆为对象，对象上有其属性和行为



### 4.1 封装

#### 4.1.1 封装的意义

封装是c++面向对象的三大特征之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制



**封装的意义一：**

在设计类的时候，属性和行为写在一起，表现事物。

**语法:** `class 类名{访问权限：属性 / 行为}；`

**示例1:**设计一个圆类，求圆的周长

```c++
// 设计一个圆类，求圆的周长
#define PI 3.14

class Circle {
    // 访问权限
public:
    // 属性
    int m_r;

    // 行为
    double calculateZC() {
        return 2 * PI * m_r;
    }
};

int main() {
    // 通过圆类，创建具体的圆
    Circle c1;
    c1.m_r = 10;

    cout << c1.calculateZC() << endl;
}
```



**封装的意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种:

1. `public` 公共权限：类内可以访问，类外可以访问
2. `protected` 保护权限：类内可以访问，类外不可以访问 子类可以访问父类中的保护内容
3. `private` 私有权限：类内可以访问，类外不可以访问 子类不可以访问父类中的私有内容



#### 4.1.2 struct和class的区别

在C++中struct和class唯一的区别在于==默认的访问权限不同==

区别：

- struct默认权限为**公共**
- class默认权限为**私有**



#### 4.1.3 将成员属性设置为私有

**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限

**优点2：** 对于写权限，我们可以检测数据的有效性

```c++
class Person {
private:
    string m_Name; // 可读可写
    int m_age = 0; // 只读
    string m_Lover; // 只写

public:
    void setName(string name) {
        m_Name = name;
    }

    string getName() {
        return m_Name;
    }

    int getAge() {
        return m_age;
    }

    // 如果只读，不要set，这里演示的是检测数据有效性。
    void setAge(int age) {
        if (age < 0 || age > 150) {
            cout << "Wrong!" << endl;
            return;
        }
        m_age = age;
    }

    void setLover(string lover) {
        m_Lover = lover;
    }
};

int main() {
    Person p1;
    p1.setName("Amy");
    p1.setLover("Tom");
    cout << p1.getName() << endl;
    cout << p1.getAge() << endl;
}
```



#### 4.1.4 将不同的类写在多文件中

```c++
// point.h 文件

#pragma once // 保证同一个文件不会被包含多次
#include <iostream>
using namespace std;

class Point {
private:
    int m_X;
    int m_Y;

public:
    void setX(int x); // 只写函数声明

    int getX();

    void setY(int y);

    int getY();
};
```



```c++
// point.cpp 文件

#include "point.h"

void Point::setX(int x) { // 在写函数定义时，要明确函数的作用域，使用：“类名”+::
    m_X = x;
}

int Point::getX() {
    return m_X;
}

void Point::setY(int y) {
    m_Y = y;
}

int Point::getY() {
    return m_Y;
}
```



### 4.2 对象的初始化和清理

#### 4.2.1 构造函数和析构函数

对象的初始化和清理是两个非常重要的安全问题

- 一个对象或变量没有初始状态，对其使用后果是未知的。
- 同样的，使用完一个对象或变量，没有及时清理，也会造成一定的安全问题。

c++利用构造函数和析构函数，完成对象的初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是**空实现**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
- 析构函数：只要作用在于对象销毁前系统自动调用，执行一些清理操作。



**构造函数语法：** `类名() {}`

1. 构造函数，没有返回值，也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序会自动调用构造，无需手动调用，而且只会调用一次。



**析构函数语法：** `~类名() {}`

1. 析构函数，没有返回值，也不写void
2. 函数名称与类名相同，在名称前面加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次。

```c++
class Person {
public:
    // 构造函数
    Person() {
        cout << "person" << endl;
    }

    // 析构函数
    ~Person() {
        cout << "~person" << endl;
    }
};

```











# C++常用函数记录

| 函数                                 | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `system("pause");`                   | 请按任意键继续                                               |
| `system("cls");`                     | 清屏操作                                                     |
| `Sleep(1000);`  #include <windows.h> | 使程序暂停1000毫秒                                           |
| `endl与ends、flush的区别`            | endl表示输出并换行，ends表示输出加一个空格，flush表示什么都不加，直接输出 |
|                                      |                                                              |

