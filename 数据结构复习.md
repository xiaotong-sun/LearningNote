# 第一章 绪论

## 1.1 数据结构的基本概念

**数据：** 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。

**数据元素：** 是数据的基本单位，通常作为一个整体进行考虑和处理。

**数据项：** 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。

**数据对象：** 是==具有相同性质==的数据元素的集合，是数据的一个子集。

**数据结构：** 是相互之间存在一种或多种==特定关系==的数据元素的集合。**数据结构**是计算机中存储、组织数据的方式。



## 1.2 数据结构的三要素

<center> <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/1.png" width = "60%" /> </center>




**集合结构：** 各个元素同属一个集合，别无其他关系

**线性结构：** 数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一的前驱；除了最后一个元素，所有元素都有唯一的后继。

**树形结构：** 数据元素之间是一对多的关系。

**图状结构：** 数据元素之间是多对多的关系。



**数据的运算：** 对于每一种特定的数据结构，定义出相应的数据操作。（例如：增删改查等）

**物理结构：** 数据在计算机内存中的实际存储方法，主要包括==顺序存储、链式存储、索引存储、散列存储==。数据的存储结构会影响存储空间分配的方便程度，会影响数据运算的速度。



## 1.3 数据类型、抽象数据类型

**数据类型：** 是一个==值的集合==和定义在此集合上的==一组操作==的总称。

- 原子类型，其值不可再分的数据类型。（例如：bool，int）
- 结构类型，其值可以再分的数据类型。（例如：struct结构体）

**抽象数据类型（Abstract Data Type）：** 是抽象数据组织及与之相关的操作。定义一个ADT实际上就是定义一个数据结构。





## 1.4 算法的基本概念

**算法：** 是对特定问题求解步骤的一种描述，它是指令的有限序列。

**算法的特性：** （有一个不满足，则不称之为算法）

- 有穷性 （在有限的步骤和时间内可以得到结果）
- 确定性 （对同一个输入，必须有同一个输出）
- 可行性 （算法可以通过编程来实现）
- 输入 （有0个或多个输入）
- 输出 （有1个或多个输出）



**“好算法”的特质：** 

- 正确性 （正确的求解问题）
- 可读性 （易于理解）
- 健壮性 （耐操，对非法输入能够正确的处理）
- 高效率和低存储量 （时间复杂度和空间复杂度低）



## 1.5 算法的时间复杂度

**什么是时间复杂度：** 算法的时间复杂度是一个函数，它定性的描述该算法的运行时间。

<center> <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/2.png" width = "60%" /></center>





- 加法规则：
    $$
    T(n) = T_1(n) + T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
    $$

- 乘法规则：
    $$
    T(n) = T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
    $$
    

**算法的时间复杂度：** $O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$

<center>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/3.png" width = "60%" />
    <br>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/4.png" width = "60%" />
</center>




## 1.6 算法的空间复杂度

**算法原地工作：**指算法的空间复杂度为常数级。

案例：

<center> 
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220414151900763.png" alt="image-20220414151900763" width = "60%" />
    <br><br>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220414152120057.png" alt="image-20220414152120057" width = 60% />
</center>

​    

# 第二章 线性表

## 2.1 线性表的定义

**定义：** 线性表是==具有相同数据类型==的n个数据元素的==有限序列==，其中n为表长。

- 每个元素所占用的空间一样大

- 有次序，且有限

Eg: 所有整数按递增次序排列是线性表吗？ 答：不是，因为不是有限。



## 2.2 顺序表

### 2.2.1 顺序表的定义

**定义:** 顺序表是指用顺序存储的方式实现线性表。

**顺序存储**指的是把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。

如果说线性表的定义是从逻辑结构的角度出发，那么顺序表的定义就是从物理结构的角度出发。



**顺序表的特点：** 

1. 随机存取，可以在$O(1)$时间内找到第$i$个元素
2. 存储密度高
3. 拓展容量不方便
4. 插入、删除操作不方便，需要移动大量元素

**补充：** 随机存取，亦称直接访问，代表同一时间访问一组序列中的一个随意元素。



### 2.2.2 顺序表的实现

<center> <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220415144452026.png" alt="image-20220415144452026" width = "50%" /></center>



### 2.2.3 顺序表的插入和删除

<center>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220415150740990.png" alt="image-20220415150740990" width=50% />
    <br>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220415150921858.png" alt="image-20220415150921858" width=50% />
</center>


## 2.3 单链表

### 2.3.1 单链表的定义

**定义:** 单链表是指用链式存储的方式实现线性表。

 

**单链表的特点：** 

1. 不要求大片的连续空间，改变容量方便。
2. 不可随机存取
3. 需要耗费空间来存储指针



### 2.3.2 单链表的初始化

**初始化单链表：** 可以分为==带头结点的单链表==和==不带头结点的单链表==

```c++
// 带头结点的单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) { // 初始化
	/*  (DLinklist &L)这种写法是C++的引用变量声明，虽然(DLinklist <=> DNode *) 等价，但是不能写成(DNode * &L)因为这不是合法的声明变量形式。
		(int &a)是c++中声明引用变量的方式，这里的&不表示取地址。
		如果非得写成DNode * 的格式，则必须使用双指针。
	*/
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L -> next = NULL;
    return true;
}

bool Empty(LinkList L) { // 判空
    return (L -> next == NULL);
}
```



```c++
// 不带头结点的单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;
    return true;
}

bool Empty(LinkList L) {
    return L == NULL;
}
```



### 2.3.3 单链表的插入

**单链表的插入操作：**可以分为前插操作和后插操作。其中后插操作比较简单，而前插操作稍微复杂一点。

**前插操作的两种实现方式：**（假设p结点为需要前插的结点）

1. 遍历单链表，找到P结点的前一个结点，对前一个结点进行后插操作
2. 创建一个新的结点，对p结点进行后插操作，然后将p结点的内容复制到新的结点中，将要插入的内容加到p结点上。

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220416090942792.png" alt="image-20220416090942792" width = 60% /></center>



### 2.3.4 单链表的删除操作

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417102738170.png" alt="image-20220417102738170" width=60% /></center>

**注意：**这种方式对最后一个节点的删除操作不适用。

### 2.3.5 单链表的建立

**尾插法建立单链表：**

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220416103734628.png" alt="image-20220416103734628" width = 60% /></center>

**头插法建立单链表：** 重要应用是==单链表的逆置==

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220416103922289.png" alt="image-20220416103922289" width = 60% /></center>



```c
// 单链表的原地逆置操作
LinkList Reverse(LinkList l)
{
    ListNode* p;
    ListNode* s;
    p=l->next;
    s=p->next;
    l->next=NULL;
    while(p!=NULL)
    {
        p->next=l->next;
        l->next=p;
        p=s;
        if(p!=NULL)
           s=p->next;
    }
    return l;
}
```



##  2.4 双链表

### 2.4.1 双链表的初始化

**带头结点的双链表**

```c++
typedef struct DNode {
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinklist;

bool InitDLinklist(DLinklist &L) { 
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }
    L -> prior = NULL;
    L -> next = NULL;
    return true;
}

bool Empty(DLinklist L) {
    if (L -> next == NULL) {
        return true;
    }
    return false;
}

void testDLinklist() {
	DLinklist L;
    InitDLinklist(L);
}
```



### 2.4.2 双链表的插入

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417100434525.png" alt="image-20220417100434525" width=50% /></center>

**后插操作：**

```c++
bool InsertNextDNode(DNode *p, DNode *s) {
    if (p == NULL || s == NULL) {
        return false;
    }
    s -> next = p -> next;
    if (p -> next != NULL) { // 针对在最后一个结点插入的特殊情况。
        p -> next -> prior = s;
    }
    s -> prior = p;
    p -> next = s;
    return true;
}
```



**前插操作：**

双链表的前插操作可以充分利用双链表的特性，首先，利用前向指针找到前一个结点，然后对前一个结点执行后插操作即可。



### 2.4.3 双链表的删除

<center>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417100608752.png" alt="image-20220417100434525" width=50% />
	<br><br>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417100725094.png" alt="image-20220417100434525" width=50% />
    <br><br>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417100837026.png" alt="image-20220417100434525" width=50% /></center> 

```c++
// 删除p结点的后继节点
bool DeleteNextDNode(DNode *p) {
    if (p == NULL) {
        return false;
    }
    DNode *q = p -> next;
    if (q == NULL) {
        return false;
    }
    p -> next = q -> next;
    if (q -> next != NULL) { // 针对删除最后一个结点的特殊情况。
        q -> next -> prior = p;
    }
    free(q);
    return true;
}

// 双链表的销毁
bool DestoryList(DLinklist &L) {
    while(L -> next != NULL) {
        DeleteNextDNode(L);
    }
    free(L);
    L = NULL;
}
```



## 2.5 循环链表

### 2.5.1 循环单链表

#### 2.5.1.1 初始化及判空

循环单链表的初始化操作和单链表的初始化操作类似，只不过单链表初始化时头结点的next指针指向NULL，而循环单链表的头结点的next指针指向自身。

<center>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417140940016.png" alt="image-20220417140940016" width=20% />
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417141017311.png" alt="image-20220417141017311" width=50% />
</center>



```c++
typedef struct LNode {
	ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L -> next = L;
    return true;
}

bool Empty(LinkList L) {
    if (L -> next == L) {
        return true;
    }
    return false;
}
```



### 2.5.2 循环双链表

#### 2.5.2.1 初始化及判空

<center>
    <img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417141103724.png" alt="image-20220417141103724" width=50% />
</center>

```c++
typedef struct DNode {
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinklist;

bool InitDLinklist(DLinklist &L) { 
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }
    L -> prior = L;
    L -> next = L;
    return true;
}

bool Empty(DLinklist L) {
    if (L -> next == L) {
        return true;
    }
    return false;
}
```



#### 2.5.2.2 插入和删除操作

在双链表的插入和删除中，我们均需要对==最后一个结点==进行特殊的处理，但是在循环双链表中，则不需要对其特殊处理

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417141646704.png" alt="image-20220417141646704" width=50% /></center>

```c++
bool InsertNextDNode(DNode *p, DNode *s) { // 将s结点插入到p结点之后
    s -> next = p -> next;
    s -> next -> prior = s;
    s -> prior = p;
    p -> next = s;
}
```

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417142734906.png" alt="image-20220417142734906" width=50% /></center>

```c++
bool DeleteNextNode(DNode *p) { // 删除p结点的后继结点q
    DNode *q = p -> next;
    p -> next = q -> next;
    q -> next -> prior = p;
    free(q);
}
```



## 2.6 静态链表

### 2.6.1 静态链表的定义

**静态链表是用数组的方式实现的链表**

优点：增删操作不需要大量移动元素

缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变

适用场景：

1. 不支持指针的低级语言
2. 数据元素数量固定不变的场景

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/jingtailianbiao.jpg" alt="jingtailianbiao" width=50% /></center>

```c++
# define MaxSize 10
struct Node{
    ElemType data;
    int next;
};

void testSLinkList() {
    struct Node a[MaxSize];
    // 后续代码
}

// 另外一种等价方式
# define MaxSize 10
typedef struct Node{
    ElemType data;
    int next;
} SLinkList[MaxSize];

void testSLinkList() {
    SLinkList a;
    // 后续代码
}

// 也就是说 struct Node a[MaxSize] <==> SLinkList a;
```



### 2.6.2 静态链表的操作

<center><img src="https://xiaotong-sun2.oss-cn-beijing.aliyuncs.com/typora/DataStructure/image-20220417150639012.png" alt="image-20220417150639012" width=50% /></center>



## 2.7 小结

顺序表和链表的==逻辑结构==都是线性结构，都属于线性表。但是两者的==存储结构==不同：顺序表采用顺序存储，具有随机存取和存储密度高的优点，同时也有改变容量不方便的缺点；链表采用链式存储，具有改变容量方便的优点，同时也有不可随机存取和存储密度低的缺点。

由于采用不同的存储结构，因此两者的基本操作的实现效率也有所不同：

1. 初始化：
    - 顺序表需要预分配大片连续空间，若分配空间过小则后期拓容不便，若分配空间过大则浪费内存资源
    - 链表只需分配一个头结点，之后方便拓展
2. 销毁
    - 采用静态分配的顺序表使用完之后由系统自动回收空间，采用动态分配的顺序表需要手动free
    - 链表则需要依次删除各个结点
3. 增删
    - 顺序表插入和删除元素都需要将后续元素进行移动，时间复杂度为O(n)
    - 链表插入和删除元素只需要修改指针即可，虽然时间复杂度也为O(n)，但是主要来自查找目标元素上。
4. 查找
    - 顺序表按位查找的时间复杂度为O(1)，按值查找的时间复杂度为O(n)
    - 链表按位查找和按值查找的时间复杂度均为O(n)

**当表长难以估计、经常需要增删元素时---------> 链表**

**当表长可以估计、经常需要查询元素时---------> 顺序表**

