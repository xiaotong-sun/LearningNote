# C++中二维数组的初始化

> 在C++中，用以下方式声明一个数组：
>
> ```
> int a = 3, b = 4;
> int array[a][b];
> ```
>
> 请问，能否用`int array[a][b] = {0};`来使得数组中的元素全部初始化为0？



不能使用`int array[a][b] = {0};`来初始化这种方式声明的数组。根据C++的规则，数组的大小必须是编译时常量，而不是变量。因此，使用变量a和b来声明数组的大小是不被允许的。要实现全部初始化为0的效果，你可以使用循环来为数组的元素赋值，或者使用std::fill函数进行填充。以下是两种示例方法：

**1.使用循环初始化数组**：

```c++
int a = 3, b = 4;
int array[a][b];

for (int i = 0; i < a; ++i) {
	for (int j = 0; j < b; ++j) {
		array[i][j] = 0;
	}
}
```

 

**2.使用 std::fill 函数初始化数组（需要包含头文件 `<algorithm>`）：**

```c++
#include <algorithm>

 int a = 3, b = 4;
 int array[a][b];

 std::fill(&array[0][0], &array[0][0] + a * b, 0);
```

 

**3.使用memset函数初始化数组（需要包含头文件<memory.h>或<string.h>）：**

```
#include <string.h>

int a = 3, b = 4;
int array[a][b];
memset(array, 0, sizeof(array));
```

==注意：==
这种方式<u>只适用于初始化为0</u>的情况。如果初始化为其他值会产生奇怪的结果。具体原因如下：
memset是按照字节对待初始化空间进行初始化的，也就是说，函数里面的第二个参数的那个初值（一般为0）是按照一个一个字节往第一个参数所指区域赋值的，所以，对于单字节数据类型（char）可以初始化为任意支持的值，都没有问题，但是对于非多字节数据类型只能初始化为0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值0的结果都是0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果。比如说，上面的例3之所以没有出错就是因为初始化为0，但是如果初始化为1，那么因为int一般是4个字节，那么相当于将一个int元素初始化成了<u>0000 0001 0000 0001 0000 0001 0000 0001</u>，这样对于一个int元素肯定不是1，而是一个很大的数，结果出乎意料，所以一定要记住这一点，非常重要！！！
原文链接：https://blog.csdn.net/dan15188387481/article/details/49621447